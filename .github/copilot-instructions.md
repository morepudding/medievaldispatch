# Medieval Dispatch - AI Coding Agent Instructions

## Project Overview

**Medieval Dispatch** is a Next.js 14 time-management RPG where players alternate between 60-second "Dispatch" phases (assigning heroes to timed missions on a map) and "Social" phases (village management, dialogues, building upgrades). The game runs in 3-day cycles with progressive mission unlocking.

**Tech Stack**: Next.js 14 (App Router), TypeScript, Prisma 5, PostgreSQL (Supabase), React Context for state.

**Content Pipeline**: Game content (heroes, missions, dialogues, images) is generated by a separate AI curator pipeline. Our role is to create game mechanics and database entries, then send content requests to the curator. See `docs/roadmapcuratorv2.md` for the complete content generation workflow.

**Current Content Status** (as of Nov 23, 2025):
- 5 heroes with placeholder descriptions (need enrichment)
- 15 missions (functional but generic)
- 3 dialogues (narrative but incomplete)
- 4 locations, 5 buildings (basic descriptions)

## Architecture & Data Flow

### Two-Database Architecture
- **Supabase (PostgreSQL)**: Persistent game content (heroes, missions, dialogues, buildings) and save data
  - Content tables: `heroes`, `missions`, `dialogues`, `buildings`, `locations` (read-only for game)
  - Save tables: `game_saves`, `player_heroes`, `mission_completions`, `player_dialogues`, `player_buildings`
- **localStorage**: UI preferences only (`stamps` for map decorations, `village_placements` for hero positions)

### Key Data Flows
1. **Game Load**: Page load → `GameContext.tsx` → `/api/save/[id]` → Prisma → Supabase → Hydrate state
2. **Mission Complete**: Dispatch page → `MissionCalculator.calculateSuccess()` → Update `GameContext` → `/api/save/[id]/missions` POST → Prisma upsert
3. **Next Day**: Village → `nextDay()` → Clear localStorage UI state → `/api/missions/day/[day]` + `/api/dialogues/day/[day]` → Load new content

### Critical Files to Understand
- `app/contexts/GameContext.tsx` (803 lines): Global state manager - all game actions flow through here
- `prisma/schema.prisma`: Database schema with content/save table separation
- `app/dispatch/page.tsx`: 60-second timer with progressive mission spawning
- `app/components/village/VillageModal.tsx`: Village orchestrator after major Sprint 5C refactor (1,638→488 lines)

## Development Patterns

### Database Access Pattern
**Always use Prisma through API routes** - never query DB from client components:
```typescript
// ✅ CORRECT: From app/api/heroes/route.ts
export async function GET() {
  const heroes = await prisma.hero.findMany({ include: { images: true }})
  return NextResponse.json(heroes)
}

// ❌ WRONG: Never in client components
'use client'
export default function MyComponent() {
  const data = await prisma.hero.findMany() // This will fail!
}
```

### State Management Convention
- **GameContext**: Source of truth for game state, heroes, missions, gold, day counter
- **Local useState**: UI-only state (modals open/closed, selected items, animations)
- **localStorage via StorageManager**: Only for UI preferences that persist across sessions (see `app/lib/utils/storage.ts`)

### Component Organization (Post-Sprint 5C Refactor)
Village components in `app/components/village/` follow strict single-responsibility:
- `VillageModal.tsx`: Orchestrator only - delegates to specialized components
- `VillageLightPoint.tsx`: Single interactive hero placement point with menu/tooltip
- `VillagePlacementsList.tsx`: Maps placement array to `VillageLightPoint` instances
- `VillageConfirmationModals.tsx`: All confirmation dialogs (next day, reset)
- See `app/components/village/README.md` for complete 330-line architecture doc

### Mission Success Calculation
Use `MissionCalculator` utility (see `app/lib/utils/missionLogic.ts`):
```typescript
const heroes = [hero1, hero2]
const successRate = MissionCalculator.calculateSuccessRate(heroes, mission)
const willSucceed = MissionCalculator.performCheck(successRate)
// Caps at 150% per stat, uses weighted average
```

## Critical Workflows

### Running the Project
```bash
npm run dev              # Start Next.js dev server (localhost:3000)
npm run prisma:generate  # Generate Prisma client after schema changes
```

### Database Migrations
**ALWAYS use Prisma for schema changes**:
```bash
# 1. Edit prisma/schema.prisma
# 2. Push to Supabase (dev/staging only)
npx prisma db push
# 3. For production, create migration
npx prisma migrate dev --name descriptive_name
```
**Note**: Uses dual connections - `DATABASE_URL` (pooled, port 6543) for queries, `DIRECT_URL` (direct, port 5432) for migrations.

### Adding New Heroes/Content
Content lives in DB, not code and is generated by the AI curator pipeline:
1. Define content structure in Prisma schema
2. Send request to curator with specs (see `docs/roadmapcurator.md`)
3. Curator generates JSON + assets
4. Run Prisma seed script to populate DB
5. Client fetches via API routes automatically (e.g., `/api/heroes`)

**Note**: We create mechanics and DB structure, curator generates actual content (text, images).

## Common Pitfalls & Solutions

### ❌ Don't: Hardcode Game Content
```typescript
const HEROES = [{ name: "Bjorn", stats: {...} }] // Hard to update!
```
✅ **Do**: Fetch from DB via API routes, store in GameContext.

### ❌ Don't: Mutate GameContext State Directly
```typescript
gameState.gold = 100 // React won't re-render!
```
✅ **Do**: Use `setGameState(prev => ({ ...prev, gold: 100 }))` or context methods like `addGold(50)`.

### ❌ Don't: Use `window` for React State
VillageModal previously used `(window as any).selectedHero` - this was an anti-pattern eliminated in Sprint 5C.
✅ **Do**: Use `useState` for component-local state or context for shared state.

### ❌ Don't: Create 500+ Line Components
Sprint 5C split VillageModal (1,638 lines) into 6 focused components.
✅ **Do**: Follow single-responsibility principle - orchestrators delegate to specialized children.

## Type System Conventions

### Game Types Location
All game-specific types in `app/types/game.ts`:
```typescript
export interface Hero { id, name, stats: HeroStats, isAvailable, currentMissionId? }
export interface Mission { id, titre, requiredStats, status: MissionStatus, ... }
export type MissionStatus = 'pending' | 'disponible' | 'en_cours' | 'terminee' | 'echouee'
```

### Prisma-Generated Types
After schema changes, regenerate types:
```bash
npm run prisma:generate
```
Import from `@prisma/client`: `import { Hero, GameSave } from '@prisma/client'`

## Visual & Styling Patterns

### Centralized Design Constants
**Always use** constants from `app/lib/constants/styles.ts`:
```typescript
import { COLORS, SPACING, SHADOWS, TRANSITIONS, BORDER_RADIUS, Z_INDEX } from '@/app/lib/constants/styles'
// ✅ background: COLORS.CARD_BG
// ❌ background: '#1e1e1e'
```

### Animations
Global animations in `app/styles/animations.css`:
```css
@keyframes glow { /* pulsing point effect */ }
@keyframes fadeIn { /* modal appearances */ }
```
Reference via: `animation: glow 2s ease-in-out infinite`

## Environment Setup

Required `.env.local`:
```bash
DATABASE_URL="postgresql://postgres:[password]@[host]:6543/postgres?pgbouncer=true"
DIRECT_URL="postgresql://postgres:[password]@[host]:5432/postgres"
```
See `docs/supabase-setup.md` and `docs/prisma-setup.md` for detailed setup.

## Testing & Debugging

### No Formal Test Suite Yet
Current workflow: manual testing in browser. When adding tests:
- Unit tests: Mission calculation logic in `missionLogic.ts`
- Integration: API routes (Prisma queries)

### Debug Patterns
```typescript
// GameContext exposes debug info
console.log('Current state:', gameState)
// Check localStorage UI state
console.log('Placements:', StorageManager.loadVillagePlacements())
```

## Documentation Map

- `docs/roadmap.md`: 3-day MVP scope, mission mechanics (784 lines)
- `docs/roadmapcuratorv2.md`: **Content generation pipeline with AI curator** - Complete specs for enriching placeholder content
- `docs/refactoring.md`: Technical debt tracker (775 lines)
- `docs/roadmap-refactoring.md`: Refactor sprints changelog (1,451 lines) 
- `docs/database.md`: DB schema rationale (692 lines)
- `app/components/village/README.md`: Village component architecture post-refactor (330 lines)

When uncertain about game mechanics or architecture decisions, these docs contain detailed context not obvious from code inspection alone.
